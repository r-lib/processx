<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>processx internals • processx</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Source_Sans_Pro-0.4.9/font.css" rel="stylesheet">
<link href="../deps/Source_Code_Pro-0.4.9/font.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="processx internals">
<script defer data-domain="processx.r-lib.org,all.tidyverse.org" src="https://plausible.io/js/plausible.js"></script>
</head>
<body>
    <a href="#container" class="visually-hidden-focusable">Skip to content</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-none" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">processx</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="Released version">3.8.6</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/internals.html">processx internals</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/r-lib/processx/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article" id="container">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>processx internals</h1>
                        <h4 data-toc-skip class="author">Gábor
Csárdi</h4>
            
            <h4 data-toc-skip class="date">2025-02-21</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/r-lib/processx/blob/main/vignettes/internals.Rmd" class="external-link"><code>vignettes/internals.Rmd</code></a></small>
      <div class="d-none name"><code>internals.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="fifos">FIFOs<a class="anchor" aria-label="anchor" href="#fifos"></a>
</h2>
<div class="section level3">
<h3 id="unix-fifos">Unix FIFOs<a class="anchor" aria-label="anchor" href="#unix-fifos"></a>
</h3>
<p>In Unix a FIFO is an interprocess communication device with a
star-topology. (That’s right, a FIFO can have multiple readers and
writers.) It has an entry in the file system, although most of the time
the data in the FIFO is never written to the disk.</p>
<p>Unix FIFO operations:</p>
<ol style="list-style-type: decimal">
<li>Creating the FIFO in the file system. <code>mkfifo(2)</code> system
call.</li>
<li>Opening the FIFO. <code>open(2)</code>.</li>
<li>Polling the FIFO. We use normal <code>poll(2)</code> as for
everything else.</li>
<li>Reading from the FIFO. <code>read(2)</code>.</li>
<li>Writing to the FIFO. <code>write(2)</code> and friends.</li>
<li>Closing the FIFO. <code>close(2)</code>.</li>
</ol>
</div>
<div class="section level3">
<h3 id="blocking-vs-non-blocking-mode">Blocking vs Non-blocking mode<a class="anchor" aria-label="anchor" href="#blocking-vs-non-blocking-mode"></a>
</h3>
<p>The processx functions support opening the FIFO in blocking and
non-blocking mode. Blocking mode is not very useful because
<code><a href="https://rdrr.io/r/base/connections.html" class="external-link">open()</a></code> will block until the other side of the FIFO is
<code><a href="https://rdrr.io/r/base/connections.html" class="external-link">open()</a></code>-d by at least one process. This is cumbersome to
ensure and can often lead to deadlocks. E.g. the other process fails to
start and connect to the FIFO, and then we block fovever.</p>
<p>Blocking processx FIFOs are not tested very well, and unless noted
otherwise this document is about non-blocking FIFOs.</p>
</div>
<div class="section level3">
<h3 id="processxs-fifos-on-unix">processx’s FIFOs on Unix<a class="anchor" aria-label="anchor" href="#processxs-fifos-on-unix"></a>
</h3>
<p><code><a href="../reference/processx_fifos.html">conn_create_fifo()</a></code> first creates the FIFO with
<code>mkfifo(2)</code> (1 above) and then opens it with
<code>open(2)</code> (2 above). If <code>read = TRUE</code> then this is
the reader end (<em>a</em> reader end, really), if
<code>write = TRUE</code> then it is the writer. For the writer end, we
need to open non-blocking FIFOs for read-write, because otherwise the
<code><a href="https://rdrr.io/r/base/connections.html" class="external-link">open()</a></code> fails if the FIFO does not have a reader. Weird, but
this is how it is on Unix. Even weirder, according to POSIX, opening a
FIFO in read-write mode is undefined behavior. On Linux the documented
behavior is that <code>O_RDWR</code> does succeeds even if there is no
reader (well, there is now). Apparently, this is also the bevarios on
macOS. Many people say on the internet, and this is the standard
behavior on all Unix systems.</p>
<p><code><a href="../reference/processx_fifos.html">conn_connect_fifo()</a></code> connects to an existing FIFO using
<code>open(2)</code> (2 above). (Created by processx or not.) Just like
<code><a href="../reference/processx_fifos.html">conn_create_fifo()</a></code> it opens the FIFO in read-write mode
instead of write-only mode. This helps with the situations when the FIFO
file exists but no reader is connected to it (yet). On Unix
<code><a href="../reference/processx_fifos.html">conn_connect_fifo()</a></code> fails if the FIFO file does not exist,
or we have no permissions to open it in the specified mode.</p>
<p>The rest of the operations (3-6 above) are the usual processx
connection operations, there is nothing special about FIFO connections
once they are opened.</p>
</div>
<div class="section level3">
<h3 id="emulating-fifos-with-named-pipes-on-windows">Emulating FIFOs with named pipes on Windows<a class="anchor" aria-label="anchor" href="#emulating-fifos-with-named-pipes-on-windows"></a>
</h3>
<p>Windows does not quite have the equivalent of FIFOs, but we can
reasonably emulate them with named pipes.</p>
<p><code><a href="../reference/processx_fifos.html">conn_create_fifo()</a></code> creates a named pipe with
<code>CreateNamedPipeA()</code> with the specified name. This
corresponds to creating the FIFO and opening it (1-2 above).</p>
<p><code><a href="../reference/processx_fifos.html">conn_connect_fifo()</a></code> opens a named pipe, like a regular
file, with <code>CreateFileA()</code> (2 above).</p>
<p>Once opened, the FIFOs work like regular connections. Well, mostly.
See the notes about known platform differences below!</p>
</div>
<div class="section level3">
<h3 id="how-to">How-to<a class="anchor" aria-label="anchor" href="#how-to"></a>
</h3>
<div class="section level5">
<h5 id="how-to-check-if-the-other-write-end-of-the-fifo-is-connected">How to check if the other write-end of the FIFO is connected?<a class="anchor" aria-label="anchor" href="#how-to-check-if-the-other-write-end-of-the-fifo-is-connected"></a>
</h5>
<p>If you have the read end, then use <code><a href="../reference/poll.html">poll()</a></code> to see if
there is data in the FIFO. There is no way to know currently when the
other end connects, but once it writes data, <code><a href="../reference/poll.html">poll()</a></code> will
return <code>ready</code> .</p>
</div>
<div class="section level5">
<h5 id="how-to-check-if-the-other-read-end-of-the-fifo-is-connected">How to check if the other read-end of the FIFO is connected?<a class="anchor" aria-label="anchor" href="#how-to-check-if-the-other-read-end-of-the-fifo-is-connected"></a>
</h5>
<p>If you have the write end, then unfortunately there is no easy way to
make sure that the other end is connected. You can try to write to the
FIFO, and on Unix it might succeed, and on Windows it might fail. If you
need to make sure that there is a reader at the other end, then you’ll
need another FIFO in the opposite direction, where the reader can send a
message about being connected. (Or some other way to communicate this.)
This is admittedly not great, and make it much more difficult to use
FIFOs.</p>
</div>
<div class="section level5">
<h5 id="how-to-check-for-end-of-fifo">How to check for end-of-FIFO?<a class="anchor" aria-label="anchor" href="#how-to-check-for-end-of-fifo"></a>
</h5>
<p>This is as usual. A non-blocking read returns zero bytes if there is
no more data and there are no more writers connected to the FIFO. On
Unix maybe there will be more writers later, but processx does not care
about that. Once a connection is set to EOF, it is EOF.
<code><a href="../reference/processx_connections.html">conn_is_incomplete()</a></code> returns <code>FALSE</code> if EOF is
set. (As usual, it only makes sense to check this after a
<code>read()</code>.</p>
</div>
<div class="section level5">
<h5 id="how-to-communicate-with-another-process">How to communicate with another process?<a class="anchor" aria-label="anchor" href="#how-to-communicate-with-another-process"></a>
</h5>
<p>Create a FIFO with <code><a href="../reference/processx_fifos.html">conn_create_fifo()</a></code> then pass the name
of the FIFO (you can use <code><a href="../reference/processx_connections.html">conn_file_name()</a></code> to the other
program. It is a piece of text, so you can pass it as an argument. (But
watch out for special characters, especially on Windows. It is best to
use processx and avoid system.) The other program can open the FIFO (for
reading or writing) as a regular file with <code><a href="https://rdrr.io/r/base/connections.html" class="external-link">open()</a></code>,
<code>fopen()</code>, <code>CreateFile()</code>, etc. It can open it in
blocking or non-blocking mode, as needed. If you need bidirectional
communication, then use two FIFOs.</p>
</div>
</div>
<div class="section level3">
<h3 id="platform-differences-and-portable-code">Platform differences and portable code<a class="anchor" aria-label="anchor" href="#platform-differences-and-portable-code"></a>
</h3>
<p>See also the “Known issues” below.</p>
<ul>
<li><p>Do not connect more than one reader or more than one writer to a
FIFO. While this is fine on Unix, and it is pretty cool, actually, it
will fail on Windows.</p></li>
<li><p>Remember that once there are zero readers or writers on a FIFO,
the other end will signal EOF at the next read (or poll!)
operation.</p></li>
<li><p><code>conn_read_*()</code> will fail on Windows if the other end
or the FIFO is not connected. Always use <code><a href="../reference/poll.html">poll()</a></code> first and
only read if it returns <code>ready</code>. <code><a href="../reference/poll.html">poll()</a></code> will not
return <code>ready</code> if the other end of the FIFO is not
connected.</p></li>
<li><p><code><a href="../reference/processx_connections.html">conn_write()</a></code> may fail (on Windows) if the other end
of the FIFO is not connected yet and also if there are no more writers.
(But this does not always happen, e.g. if we opened the FIFO in
read-write mode in the first place!) Be prepared that every
<code><a href="../reference/processx_connections.html">conn_write()</a></code> call can fail.</p></li>
<li><p>As usual <code><a href="../reference/processx_connections.html">conn_write()</a></code> might not be able to write all
data if the pipe/FIFO buffer is full, and it will return the un-written
<code><a href="https://rdrr.io/r/base/raw.html" class="external-link">raw()</a></code> data. Make sure to check the return value of
<code><a href="../reference/processx_connections.html">conn_write()</a></code>.</p></li>
<li><p>A <code><a href="../reference/poll.html">poll()</a></code> on a FIFO can return <code>ready</code> and
then have no data on the next <code>conn_read_*()</code>, at least on
Windows. This is because at the first <code><a href="../reference/poll.html">poll()</a></code> (on Windows)
we need to start an asynchronous operation for waiting for the other end
of the pipe to connect. Once this returns, <code><a href="../reference/poll.html">poll()</a></code> will
signal <code>ready</code>, but there might be no data to read just
yet.</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="known-issues">Known issues<a class="anchor" aria-label="anchor" href="#known-issues"></a>
</h3>
<ul>
<li><p>A <code><a href="../reference/poll.html">poll()</a></code> on a FIFO might not return if the writer on
the other end (all the writers) close the FIFO. The <code><a href="../reference/poll.html">poll()</a></code>
will only return <code>ready</code> after a read operation, once the
writer have closed their end. This seems to be a macOS bug, and it is
really bad. It happens at least on macOS 12.3.1, and it does not happen
on Ubuntu 20.04.</p></li>
<li><p>Non-ASCII file names or pipe name are currently an issue. (Just
like non-ASCII file name in <code><a href="../reference/processx_connections.html">conn_create_file()</a></code> are!) We
will fix this.</p></li>
<li><p>Encodings of the pipe traffic are very little tested. We will
also fix this.</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="links">Links<a class="anchor" aria-label="anchor" href="#links"></a>
</h3>
<p><a href="https://man7.org/linux/man-pages/man7/fifo.7.html" class="external-link">Linux
<code>fifo(7)</code> manual page</a></p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea" class="external-link">Windows
<code>CreateNamedPipeA()</code> manual page</a></p>
</div>
</div>
<div class="section level2">
<h2 id="unix-domain-sockets">Unix Domain Sockets<a class="anchor" aria-label="anchor" href="#unix-domain-sockets"></a>
</h2>
<div class="section level3">
<h3 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h3>
<p>processx has a few functions to perform IPC (inter process
communication) between processes running on the same machine, using Unix
domain sockets. On Windows it uses named pipes to emulate Unix domain
sockets, as much as possible.</p>
<p>Unix domain sockets solve many issues that FIFOs (processx FIFOs and
FIFOs in general) have, so we suggest that you use sockets instead of
FIFOs if you can.</p>
</div>
<div class="section level3">
<h3 id="api">API<a class="anchor" aria-label="anchor" href="#api"></a>
</h3>
<ul>
<li><p>processx Unix sockets are always bi-directional.</p></li>
<li><p><code><a href="../reference/processx_sockets.html">conn_create_unix_socket()</a></code> creates the server side of
the socket.</p></li>
<li><p><code><a href="../reference/processx_sockets.html">conn_connect_unix_socket()</a></code> creates the client side
and connects to a server socket. This call does not block, so when it
returns, the server side has not accepted the connection yet, probably.
You can still use the client socket for reading and writing, see
below.</p></li>
<li><p>You can use <code><a href="../reference/poll.html">poll()</a></code> to wait for a client to connect
to the server. If a client is available, <code><a href="../reference/poll.html">poll()</a></code> returns
<code>"connect"</code> .</p></li>
<li><p>Once a client is available, call
<code><a href="../reference/processx_sockets.html">conn_accept_unix_socket()</a></code> to accept it.</p></li>
<li><p>After accepting the client, you can send messages to it with
<code><a href="../reference/processx_connections.html">conn_write()</a></code> and read messages from it with
<code><a href="../reference/processx_connections.html">conn_read_chars()</a></code> and <code><a href="../reference/processx_connections.html">conn_read_lines()</a></code> and in
general use the server socket as a read-write processx
connection.</p></li>
<li><p>The server cannot call <code>conn_read_*()</code> or
<code><a href="../reference/processx_connections.html">conn_write()</a></code> before accepting a connection, these calls
will error.</p></li>
<li><p>The client can call <code>conn_read_*()</code> and
<code><a href="../reference/processx_connections.html">conn_write()</a></code> as soon as it is connected. Reading functions
will return no data, and <code><a href="../reference/processx_connections.html">conn_write()</a></code> will succeed, until
the internal buffer gets full. (Or the server accepts the connection and
starts reading the data from the buffer). You can also use
<code><a href="../reference/poll.html">poll()</a></code> to wait for incoming data.</p></li>
<li><p><code><a href="../reference/poll.html">poll()</a></code> only uses the read-side of the connections,
both for the server and the client. There is currently no way to poll
the write-sides.</p></li>
<li><p>All processx Unix socket connections are non-blocking.
<code><a href="../reference/processx_sockets.html">conn_create_unix_socket()</a></code>,
<code><a href="../reference/processx_sockets.html">conn_connect_unix_socket()</a></code>,
<code><a href="../reference/processx_sockets.html">conn_accept_unix_socket()</a></code> are non-blocking as
well.</p></li>
<li>
<p><code><a href="../reference/processx_sockets.html">conn_unix_socket_state()</a></code> will return the current
state of the socket:</p>
<ul>
<li><p><code>listen</code> is a server socket before calling
<code><a href="../reference/processx_sockets.html">conn_accept_unix_socket()</a></code></p></li>
<li><p><code>connected_server</code> is a server socket with an accepted
client</p></li>
<li><p><code>connected_client</code> is a connected client</p></li>
</ul>
</li>
<li><p><code><a href="https://rdrr.io/r/base/connections.html" class="external-link">close()</a></code> closes the socket. (Both the read-end and
the write-end.)</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="file-names">File names<a class="anchor" aria-label="anchor" href="#file-names"></a>
</h3>
<p>On Unix, the socket has entry in the file system. By default it will
be created in the R temporary directory.</p>
<p>On Windows, we use a named pipe to emulate the socket. The user can
specify the name of the pipe, if they do not then a random name is used
in the <code>\\?\pipe\</code> namespace. If you specify a pipe name on
Windows, that starts with this string then processx uses it as is.</p>
<p>You can use <code><a href="../reference/processx_connections.html">conn_file_name()</a></code> to query the full path of
the socket on Unix, or the full name of the pipe on Windows.</p>
</div>
<div class="section level3">
<h3 id="how-to-1">How-to<a class="anchor" aria-label="anchor" href="#how-to-1"></a>
</h3>
<div class="section level5">
<h5 id="how-to-check-if-the-other-end-of-the-socket-is-connected">How to check if the other end of the socket is connected?<a class="anchor" aria-label="anchor" href="#how-to-check-if-the-other-end-of-the-socket-is-connected"></a>
</h5>
<p>The server socket can <code><a href="../reference/poll.html">poll()</a></code> for a client connection.
The client can assume that it is connected, but it needs to handle the
case when <code><a href="../reference/processx_connections.html">conn_write()</a></code> cannot write all the data. (As usual
for every non-blocking processx connection.)</p>
</div>
<div class="section level5">
<h5 id="how-to-check-for-the-end-of-the-connection">How to check for the end of the connection?<a class="anchor" aria-label="anchor" href="#how-to-check-for-the-end-of-the-connection"></a>
</h5>
<p>This is as usual. <code><a href="../reference/poll.html">poll()</a></code> will return with
<code>ready</code> if the other end closes the connection. You can call
<code><a href="../reference/processx_connections.html">conn_is_incomplete()</a></code> right after a <code>read()</code> to
see if the other end has closed the connection.</p>
<p><code><a href="../reference/processx_connections.html">conn_write()</a></code> will error if the other side has closed the
connection.</p>
</div>
<div class="section level5">
<h5 id="how-to-communicate-with-another-process-1">How to communicate with another process?<a class="anchor" aria-label="anchor" href="#how-to-communicate-with-another-process-1"></a>
</h5>
<p>Pass the socket (or pipe) name to it. E.g. you can pass it as a
command line argument. Note, however that passing the special file name
of the named pipe might not work on older Windows systems, and you might
want to only pass the last component of that path, and then append it to
<code>\\?\pipe\</code> in the other process. See <code>sock.c</code> in
<code>src/tools</code> for an example.</p>
<p>If the other process is an R process that can load processx, then you
can use the processx socket functions to connect to the socket and
communicate.</p>
<p>If the other process is not an R process, or it cannot load processx,
then you can include the <code>include/processx/unix-socket.{c,h}</code>
files in your project to connect to the socket and communicate. (Or
write your own C/C++ code based on these.)</p>
<p>Include the <code>.c</code> file in exactly one compilation unit of
your program, and include the <code>.h</code> file in others. These
files have a portable, blocking Unix socket implementation, with a
simple API:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="dt">int</span> processx_socket_connect<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>filename<span class="op">,</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>                            processx_socket_t <span class="op">*</span>pxsocket<span class="op">);</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="dt">ssize_t</span> processx_socket_read<span class="op">(</span>processx_socket_t <span class="op">*</span>pxsocket<span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>                             <span class="dt">void</span> <span class="op">*</span>buf<span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>                             <span class="dt">size_t</span> nbyte<span class="op">);</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="dt">ssize_t</span> processx_socket_write<span class="op">(</span>processx_socket_t <span class="op">*</span>pxsocket<span class="op">,</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>                              <span class="dt">void</span> <span class="op">*</span>buf<span class="op">,</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>                              <span class="dt">size_t</span> nbyte<span class="op">);</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="dt">int</span> processx_socket_close<span class="op">(</span>processx_socket_t <span class="op">*</span>pxsocket<span class="op">);</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="dt">const</span> <span class="dt">char</span><span class="op">*</span> processx_socket_error_message<span class="op">();</span></span></code></pre></div>
<p>All these functions are blocking, and except for the last one, they
return -1 on error, and set errno on Unix, or you can use
<code>GetLastError()</code> on Windows. You can also use
<code>processx_socket_error_message()</code> to query the system error
message in a portable way. This function returns a pointer to the error
message in a static buffer, so copy that if you need to. Note that this
is also not thread-safe.</p>
<p>In an R package you can use <code>unix-socket.{c,h}</code> via the
<code>LinkingTo</code> entry in <code>DESCRIPTION</code>, you need to
specify</p>
<pre><code><span><span class="va">LinkingTo</span><span class="op">:</span> <span class="va">processx</span></span></code></pre>
<p>and then write</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;processx/unix-sockets.h&gt;</span></span></code></pre></div>
<p>similarly for the <code>.c</code> file:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;processx/unix-sockets.c&gt;</span></span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="known-issues-1">Known issues<a class="anchor" aria-label="anchor" href="#known-issues-1"></a>
</h3>
<ul>
<li><p>Non-ASCII socket file names or pipe name are currently an issue.
(Just like non-ASCII file name in <code><a href="../reference/processx_connections.html">conn_create_file()</a></code>
are!)</p></li>
<li><p>Encodings of the traffic are very little tested.</p></li>
</ul>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



   </div>
  <footer><div class="container">
  <div class="pkgdown-footer-left">
  <p>Developed by Gábor Csárdi, Winston Chang, <a href="https://www.posit.co" class="external-link"><img src="https://www.tidyverse.org/posit-logo.svg" alt="Posit" height="16" width="62" style="margin-bottom: 3px;"></a>, Ascent Digital Services.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

  </div></footer>
</body>
</html>
