
test_that("process works", {

  px <- get_tool("px")
  p <- process$new(px, c("sleep", "5"))
  on.exit(try_silently(p$kill(grace = 0)), add = TRUE)
  expect_true(p$is_alive())
})

test_that("get_exit_status", {

  px <- get_tool("px")
  p <- process$new(px, c("return", "1"))
  on.exit(p$kill(), add = TRUE)
  p$wait()
  expect_identical(p$get_exit_status(), 1L)
})

test_that("non existing process", {
  expect_error(process$new(tempfile()))
  ## This closes connections in finalizers
  gc()
})

test_that("post processing", {

  px <- get_tool("px")
  p <- process$new(
    px, c("return", "0"), post_process = function() "foobar")
  p$wait(5000)
  p$kill()
  expect_equal(p$get_result(), "foobar")

  p <- process$new(
    px, c("sleep", "5"), post_process = function() "yep")
  expect_error(p$get_result(), "alive")
  p$kill()
  expect_equal(p$get_result(), "yep")

  ## Only runs once
  xx <- 0
  p <- process$new(
    px, c("return", "0"), post_process = function() xx <<- xx + 1)
  p$wait(5000)
  p$kill()
  p$get_result()
  expect_equal(xx, 1)
  p$get_result()
  expect_equal(xx, 1)
})

test_that("working directory", {
  px  <- get_tool("px")
  dir.create(tmp <- tempfile())
  on.exit(unlink(tmp, recursive = TRUE), add = TRUE)
  cat("foo\nbar\n", file = file.path(tmp, "file"))

  p <- process$new(px, c("cat", "file"), wd = tmp, stdout = "|")
  on.exit(p$kill(), add = TRUE)
  p$wait()
  expect_equal(p$read_all_output_lines(), c("foo", "bar"))
})

test_that("working directory does not exist", {
  px <- get_tool("px")
  expect_error(process$new(px, wd = tempfile()))
  ## This closes connections in finalizers
  gc()
})

test_that("R process is installed with a SIGTERM cleanup handler", {
  # https://github.com/r-lib/callr/pull/250
  skip_if_not_installed("callr", "3.7.3.9001")

  # Needs POSIX signal handling
  skip_on_os("windows")

  n_children <- length(ps::ps_children())

  # Enabled case
  withr::local_envvar(c(PROCESSX_R_SIGTERM_CLEANUP = "true"))

  out <- tempfile()
  defer(unlink(out, TRUE, TRUE))

  fn <- function(file) {
    file.create(tempfile())
    writeLines(tempdir(), file)
  }

  p <- callr::r_session$new()
  h <- ps::ps_handle(p$get_pid())
  p$run(fn, list(file = out))

  p_temp_dir <- readLines(out)
  expect_true(dir.exists(p_temp_dir))

  # The cleanup process has been launched
  expect_length(ps::ps_children(), n_children + 1)

  p$signal(ps::signals()$SIGTERM)
  p$wait()

  # We're no longer waiting for the cleanup process to finish so poll
  # until finished
  poll_until(function() !dir.exists(p_temp_dir))
  expect_length(ps::ps_children(), n_children)

  # The cleanup process is terminated on quit
  p <- callr::r_session$new()
  h <- ps::ps_handle(p$get_pid())

  expect_length(ps::ps_children(), n_children + 1)
  p$run(function() quit("no"))
  expect_length(ps::ps_children(), n_children)

  # Disabled case
  withr::local_envvar(c(PROCESSX_R_SIGTERM_CLEANUP = NA_character_))

  # Just in case R adds tempdir cleanup on SIGTERM
  skip_on_cran()

  p <- callr::r_session$new()
  p$run(fn, list(file = out))

  p_temp_dir <- readLines(out)
  expect_true(dir.exists(p_temp_dir))

  p$signal(ps::signals()$SIGTERM)
  p$wait()

  # Was not cleaned up
  expect_true(dir.exists(p_temp_dir))
})

test_that("can kill process tree with SIGTERM", {
  # https://github.com/r-lib/callr/pull/250
  skip_if_not_installed("callr", "3.7.3.9001")

  # Needs POSIX signal handling
  skip_on_os("windows")

  withr::local_envvar(c(PROCESSX_R_SIGTERM_CLEANUP = "true"))

  out <- tempfile()
  defer(unlink(out, TRUE, TRUE))
  file.create(out)

  fn <- function(recurse, local, file) {
    p <- NULL

    if (recurse) {
      p <- callr::r_session$new()
      p$call(
        sys.function(),
        list(recurse - 1, local = FALSE, file = file)
      )
    }

    if (!local) {
      file.create(tempfile())
      cat(paste0(tempdir(), "\n"), file = file, append = TRUE)

      # Sleeping prevents the process to receive an EOF in
      # `R_ReadConsole()` (which causes it to quit normally)
      Sys.sleep(60)
    }

    p
  }

  N <- 5
  p <- fn(N, local = TRUE, file = out)

  pid <- p$get_pid()
  id <- p$.__enclos_env__$private$tree_id

  temp_dirs <- NULL

  poll_until(function() {
    temp_dirs <<- readLines(out)
    length(temp_dirs) == N
  })

  ps <- ps::ps_find_tree(id)

  # Kill all ps-marked subprocesses, including the cleanup
  # processes. These ignore SIGTERM but should exit quickly when their
  # parent process is terminated.
  for (p in ps) {
    tools::pskill(ps::ps_pid(p))
  }
  poll_until(function() {
    !any(sapply(ps, function(p) ps::ps_is_running(p)))
  })

  expect_false(any(dir.exists(temp_dirs)))
})

test_that("can exit or sigkill parent of cleanup process", {
  # https://github.com/r-lib/callr/pull/250
  skip_if_not_installed("callr", "3.7.3.9001")

  # Needs POSIX signal handling
  skip_on_os("windows")

  withr::local_envvar(c(PROCESSX_R_SIGTERM_CLEANUP = "true"))

  p <- callr::r_session$new()
  p_handle <- ps::ps_handle(p$get_pid())

  ps <- ps::ps_children(p_handle)
  expect_length(ps, 1)
  cleanup_p <- ps[[1]]

  # Normal exit: The cleanup process gets an EOF on its stdin and exits
  p$close()
  poll_until(function() !ps::ps_is_running(cleanup_p))

  p <- callr::r_session$new()
  p_handle <- ps::ps_handle(p$get_pid())

  ps <- ps::ps_children(p_handle)
  expect_length(ps, 1)
  cleanup_p <- ps[[1]]

  # SIGKILL: Also gets an EOF
  tools::pskill(p$get_pid(), tools::SIGKILL)
  poll_until(function() !ps::ps_is_running(cleanup_p))
})

test_that("can kill process with grace", {
  # https://github.com/r-lib/callr/pull/250
  skip_if_not_installed("callr", "3.7.3.9001")

  withr::local_envvar("PROCESSX_R_SIGTERM_CLEANUP" = "true")

  # Write subprocess `tempdir()` to this file
  out <- tempfile()
  defer(rimraf(out))

  fn <- function(file) {
    file.create(tempfile())
    cat(paste0(tempdir(), "\n"), file = file)
  }
  get_temp_dir <- function(frame = parent.frame()) {
    dir <- readLines(out)
    expect_length(dir, 1)
    defer(rimraf(dir), frame = frame)
    dir
  }

  # Check that SIGTERM was called on subprocess by examining side
  # effect of tempdir cleanup
  p <- callr::r_session$new()
  p$run(fn, list(file = out))
  dir <- get_temp_dir()
  p$kill(grace = 0.1)
  poll_until(function() !dir.exists(dir))

  # When `grace` is 0, the tempdir isn't cleaned up
  p <- callr::r_session$new()
  p$run(fn, list(file = out))
  dir <- get_temp_dir()
  p$kill(grace = 0)
  expect_true(dir.exists(dir))
})

test_that("can use custom `cleanup_signal`", {
  # https://github.com/r-lib/callr/pull/250
  skip_if_not_installed("callr", "3.7.3.9001")

  withr::local_envvar("PROCESSX_R_SIGTERM_CLEANUP" = "true")

  # Should become the default in callr
  opts <- callr::r_process_options(extra = list(
    cleanup_grace = 0.1
  ))
  p <- callr::r_session$new(opts)

  out <- tempfile()
  defer(rimraf(out))

  fn <- function(file) {
    file.create(tempfile())
    writeLines(tempdir(), file)
  }
  p$run(fn, list(file = out))

  dir <- readLines(out)
  defer(rimraf(dir))

  # GC `p` to trigger finalizer
  rm(p)
  gc()

  # Needs POSIX signals
  skip_on_os("windows")

  # As usual we verify the delivery of SIGTERM by checking that the
  # callr cleanup handler kicked in and deleted the tempdir
  expect_false(dir.exists(dir))
})

test_that("can load sigtermignore", {
  p <- callr::r_session$new()
  defer(p$kill())

  p$run(load_sigtermignore)

  tools::pskill(p$get_pid(), tools::SIGTERM)
  tools::pskill(p$get_pid(), tools::SIGTERM)

  expect_true(p$is_alive())
})

test_that("can kill with SIGTERM when ignored", {
  p <- callr::r_session$new()
  defer(p$kill())

  p$run(load_sigtermignore)

  p$signal(tools::SIGTERM)
  Sys.sleep(0.05)
  expect_true(p$is_alive())
})

test_that("clean up in parallel", {
  opts <- callr::r_process_options(extra = list(
    cleanup_tree = TRUE,
    cleanup_grace = 0.2
  ))

  fn <- function(load_sigtermignore, cleanup) {
    sub_opts <- callr::r_process_options(extra = list(
      cleanup = cleanup
    ))
    s <- callr::r_session$new(sub_opts)

    # Ensure grace delay kicks in
    s$run(load_sigtermignore)

    # Make sure sessions are not closed by stdin EOF
    s$call(function() Sys.sleep(60))

    # Keep alive through options
    sessions <- c(getOption("sessions"), list(s))
    options(sessions = sessions)
  }

  # On GC
  s <- callr::r_session$new(opts)
  for (i in 1:5) s$run(fn, list(load_sigtermignore, cleanup = FALSE))

  tree <- ps::ps_find_tree(s$.__enclos_env__$private$tree_id)
  expect_true(all(sapply(tree, ps::ps_is_running)))

  rm(s)
  gc()

  # Why is this needed?
  Sys.sleep(0.05)

  expect_false(any(sapply(tree, ps::ps_is_running)))

  # On session quit
  s <- callr::r_session$new(opts)
  for (i in 1:5) s$run(fn, list(load_sigtermignore, cleanup = TRUE))

  tree <- ps::ps_find_tree(s$.__enclos_env__$private$tree_id)
  expect_true(all(sapply(tree, ps::ps_is_running)))

  s$run(function() q())

  expect_false(any(sapply(tree, ps::ps_is_running)))
})
